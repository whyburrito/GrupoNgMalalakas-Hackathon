<!doctype html>
<html>
  <head>
    <title>WhiteMask V35 | Exact Color Match</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
      :root {
        --bg-color: #0f172a;
        --sidebar-bg: #f8fafc;
        --text-dark: #1e293b;
        --accent: #334155;
      }

      body {
        margin: 0;
        background: var(--bg-color);
        font-family: "Inter", sans-serif;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }

      /* --- Sidebar --- */
      #sidebar {
        width: 360px;
        background: var(--sidebar-bg);
        padding: 20px;
        border-right: 1px solid #cbd5e1;
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 10;
        overflow-y: auto;
      }

      h2 { margin: 0; font-size: 1.2rem; color: var(--text-dark); margin-bottom: 2px; }
      .section-label { 
        font-weight: 700; font-size: 0.75rem; 
        text-transform: uppercase; color: #64748b; 
        margin-top: 8px; margin-bottom: 4px; display: block; 
      }

      /* --- Palette & Color Wheel --- */
      .palette-box { background: white; padding: 10px; border-radius: 8px; border: 1px solid #e2e8f0; }
      
      .palette-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
      
      #colorWheelInput {
        -webkit-appearance: none; border: none; width: 40px; height: 40px; cursor: pointer; padding: 0; background: none;
      }
      #colorWheelInput::-webkit-color-swatch-wrapper { padding: 0; }
      #colorWheelInput::-webkit-color-swatch { border: 2px solid #cbd5e1; border-radius: 50%; }

      .palette-presets { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; border-top: 1px solid #f1f5f9; padding-top: 8px; }
      
      .color-swatch {
        width: 20px; height: 20px; border-radius: 50%;
        cursor: pointer; border: 2px solid transparent; transition: 0.2s;
      }
      .color-swatch:hover { transform: scale(1.1); }
      
      #color-info { flex: 1; }
      #color-name-display { font-size: 0.8rem; font-weight: 700; color: #334155; }
      #color-map-display { font-size: 0.7rem; color: #64748b; font-style: italic; }

      /* --- Controls --- */
      input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; }

      /* --- Canvas Area --- */
      .canvas-area {
        position: relative;
        width: 100%;
        height: 380px; 
        border: 2px solid #cbd5e1;
        border-radius: 12px;
        background: #cbd5e1;
        overflow: hidden;
        cursor: crosshair;
      }
      canvas#paintCanvas { width: 100%; height: 100%; }

      /* --- Expression Buttons --- */
      .btn-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
      .btn {
        padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px;
        font-weight: bold; cursor: pointer; background: white; font-size: 0.75rem;
        color: #64748b; transition: 0.2s;
      }
      .btn:hover { background: #f1f5f9; }
      .btn-active { background: #0f172a !important; color: white !important; border-color: #0f172a; }

      /* --- Meter / Analysis --- */
      #meterContainer { background: #1e293b; color: white; padding: 15px; border-radius: 10px; margin-top: 5px; }
      #leadingEmotion { font-weight: bold; font-size: 1rem; color: #cbd5e1; margin-bottom: 6px; }
      
      .bar-bg { height: 10px; background: #334155; border-radius: 5px; overflow: hidden; position: relative; margin-bottom: 5px; }
      #intensityBar { height: 100%; width: 0%; background: transparent; transition: width 0.4s ease-out; display: flex;}
      .bar-segment { height: 100%; transition: width 0.3s; }
      #intensityLabel { text-align: right; font-size: 0.65rem; color: #94a3b8; }

      /* --- Pie Chart Section --- */
      #pieSection { 
        margin-top: 15px; 
        padding-top: 15px; 
        border-top: 1px solid #334155; 
        display: flex; 
        gap: 15px; 
        align-items: flex-start;
      }
      .pie-chart {
        width: 70px; height: 70px; border-radius: 50%;
        background: conic-gradient(#334155 0% 100%);
        flex-shrink: 0; border: 2px solid #334155;
      }
      .pie-legend { flex: 1; display: flex; flex-direction: column; gap: 3px; max-height: 80px; overflow-y: auto; }
      .legend-item { display: flex; align-items: center; justify-content: space-between; font-size: 0.65rem; color: #cbd5e1; }
      .legend-color { width: 6px; height: 6px; border-radius: 50%; margin-right: 6px; display: inline-block; }

      /* --- AI Summary Box --- */
      #aiSummaryBox {
        margin-top: 15px;
        background: #0f172a;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #334155;
        font-size: 0.75rem;
        color: #e2e8f0;
        line-height: 1.4;
      }
      #aiTitle { font-weight: bold; color: #38bdf8; margin-bottom: 5px; font-size: 0.7rem; text-transform: uppercase; }

      /* --- Hotline Warning --- */
      #hotlineBox {
        margin-top: 10px;
        background: #450a0a;
        border: 1px solid #ef4444;
        padding: 10px;
        border-radius: 6px;
        display: none; 
      }
      .hotline-title { color: #f87171; font-weight: bold; font-size: 0.75rem; margin-bottom: 4px; display:flex; align-items:center; gap:5px;}
      .hotline-text { color: #fecaca; font-size: 0.7rem; }
      .hotline-number { font-weight: bold; color: white; display: block; margin-top: 4px; font-size: 0.8rem;}

      .btn-reset { width: 100%; background: #ef4444; color: white; border: none; padding: 12px; border-radius: 6px; font-weight: bold; cursor: pointer; margin-top: 5px; }
      .btn-reset:hover { background: #dc2626; }

      #viewer { flex: 1; background: #0f172a; cursor: grab; }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <h2>WHITEMASK STUDIO</h2>
      
      <div class="palette-box">
        <label class="section-label" style="margin-top:0">1. Choose a color</label>
        <div class="palette-controls">
           <input type="color" id="colorWheelInput" value="#e74c3c" title="Custom Color Wheel">
           <div id="color-info">
             <div id="color-name-display">Anger / Frustration</div>
             <div id="color-map-display">Exact Match</div>
           </div>
        </div>
        <label class="section-label" style="font-size:0.65rem; color:#94a3b8;">Quick Presets</label>
        <div class="palette-presets" id="palette-container"></div>
      </div>

      <div>
        <label class="section-label">2. Brush Size: <span id="size-val">25</span>px</label>
        <input type="range" id="brushSize" min="5" max="60" value="25" step="1" oninput="updateBrushSize(this.value)">
      </div>

      <div class="canvas-area">
        <canvas id="paintCanvas" width="512" height="640"></canvas>
      </div>

      <div>
        <label class="section-label">Mask Style</label>
        <div class="btn-group">
          <button id="mode-neutral" class="btn btn-active" onclick="setExpression('neutral')">Neutral</button>
          <button id="mode-happy" class="btn" onclick="setExpression('happy')">Happy</button>
          <button id="mode-sad" class="btn" onclick="setExpression('sad')">Sad</button>
        </div>
      </div>

      <div id="meterContainer">
        <label class="section-label" style="color: #64748b; margin:0;">Leading Emotion</label>
        <div id="leadingEmotion">NEUTRAL</div>
        
        <div class="bar-bg"><div id="intensityBar"></div></div>
        <div id="intensityLabel">Intensity: 0%</div>

        <div id="pieSection">
            <div id="visualPie" class="pie-chart"></div>
            <div id="pieLegend" class="pie-legend">
                <div style="font-style:italic; color:#64748b; font-size:0.65rem;">Paint to see breakdown...</div>
            </div>
        </div>

        <div id="aiSummaryBox">
           <div id="aiTitle">AI Interpretation</div>
           <div id="aiText">The canvas is currently blank. Express yourself to begin analysis.</div>
        </div>

        <div id="hotlineBox">
            <div class="hotline-title">⚠️ Emotional Support Recommended</div>
            <div class="hotline-text">This pattern suggests high emotional distress. You don't have to carry this alone.</div>
            <span class="hotline-number">Crisis Text Line: Text HOME to 741741</span>
            <span class="hotline-number">Suicide & Crisis Lifeline: Dial 988</span>
        </div>
      </div>

      <button class="btn-reset" onclick="resetFace()">Reset Canvas</button>
    </div>

    <div id="viewer"></div>

    <script>
      // --- CONFIG & ARCHETYPES ---
      const emotions = [
        { hex: "#3498db", r:52, g:152, b:219, name: "Sadness", type: "negative" },
        { hex: "#e74c3c", r:231, g:76, b:60, name: "Anger", type: "negative" },
        { hex: "#f1c40f", r:241, g:196, b:15, name: "Joy", type: "positive" },
        { hex: "#2ecc71", r:46, g:204, b:113, name: "Growth", type: "positive" },
        { hex: "#9b59b6", r:155, g:89, b:182, name: "Fear", type: "negative" },
        { hex: "#e67e22", r:230, g:126, b:34, name: "Shock", type: "neutral" },
        { hex: "#34495e", r:52, g:73, b:94,  name: "Numbness", type: "negative" },
        { hex: "#e91e63", r:233, g:30, b:99, name: "Passion", type: "positive" }
      ];

      // State
      let currentColor = emotions[1].hex; 
      let currentBrushSize = 25;
      let currentExpression = "neutral";
      let isDrawing = false;

      // --- OFFSCREEN PAINT LAYER ---
      const paintLayer = document.createElement('canvas');
      paintLayer.width = 512; paintLayer.height = 640;
      const pCtx = paintLayer.getContext('2d');

      // --- UI REFERENCES ---
      const paletteContainer = document.getElementById("palette-container");
      const nameDisplay = document.getElementById("color-name-display");
      const mapDisplay = document.getElementById("color-map-display");
      const colorWheel = document.getElementById("colorWheelInput");

      // --- COLOR UTILS ---
      function findClosestEmotion(r, g, b) {
        let minDist = Infinity;
        let closest = null;
        emotions.forEach(emo => {
          let dist = Math.sqrt(Math.pow(r-emo.r,2) + Math.pow(g-emo.g,2) + Math.pow(b-emo.b,2));
          if (dist < minDist) { minDist = dist; closest = emo; }
        });
        return closest;
      }

      function hexToRgb(hex) {
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? { r: parseInt(result[1],16), g: parseInt(result[2],16), b: parseInt(result[3],16) } : null;
      }

      // --- INIT COLOR INPUTS ---
      colorWheel.addEventListener("input", (e) => {
        const hex = e.target.value; currentColor = hex;
        const rgb = hexToRgb(hex);
        const match = findClosestEmotion(rgb.r, rgb.g, rgb.b);
        nameDisplay.textContent = match.name; nameDisplay.style.color = match.hex;
        mapDisplay.textContent = `Maps to: ${match.name}`;
      });

      emotions.forEach(emo => {
        const dot = document.createElement("div");
        dot.className = "color-swatch"; dot.style.backgroundColor = emo.hex;
        dot.onclick = () => {
          currentColor = emo.hex; colorWheel.value = emo.hex;
          nameDisplay.textContent = emo.name; nameDisplay.style.color = emo.hex;
          mapDisplay.textContent = "Exact Match";
        };
        paletteContainer.appendChild(dot);
      });

      function updateBrushSize(val) {
        currentBrushSize = parseInt(val);
        document.getElementById("size-val").innerText = val;
      }

      // --- CANVAS LOGIC ---
      const canvas = document.getElementById("paintCanvas");
      const ctx = canvas.getContext("2d");

      function setExpression(mode) {
        currentExpression = mode;
        ["neutral", "happy", "sad"].forEach(m => {
          document.getElementById(`mode-${m}`).className = m === mode ? "btn btn-active" : "btn";
        });
        resetFace(true); 
      }

      canvas.onmousedown = () => { isDrawing = true; };
      window.onmouseup = () => { if(isDrawing) { isDrawing = false; analyzeMask(); } };
      canvas.onmousemove = (e) => {
        if (!isDrawing) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        pCtx.save(); pCtx.fillStyle = currentColor; pCtx.beginPath();
        pCtx.arc(x, y, currentBrushSize, 0, Math.PI * 2); pCtx.fill(); pCtx.restore();

        ctx.save(); ctx.globalCompositeOperation = "source-atop";
        ctx.fillStyle = currentColor; ctx.beginPath();
        ctx.arc(x, y, currentBrushSize, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        
        if (mat) { 
            mat.map.needsUpdate = true; 
            mat.alphaMap.needsUpdate = true; 
            mat.emissiveMap.needsUpdate = true;
        }
      };

      // --- ANALYSIS ENGINE ---
      function analyzeMask() {
        const imgData = pCtx.getImageData(0, 0, paintLayer.width, paintLayer.height).data;
        let emotionCounts = {}; 
        emotions.forEach(e => emotionCounts[e.name] = 0);
        let totalPaintedPixels = 0;

        for (let i = 0; i < imgData.length; i += 40) { 
          const r = imgData[i], g = imgData[i+1], b = imgData[i+2], a = imgData[i+3];
          if (a > 10) { 
            totalPaintedPixels++;
            const closest = findClosestEmotion(r, g, b);
            if (closest) emotionCounts[closest.name]++;
          }
        }

        const barContainer = document.getElementById("intensityBar");
        barContainer.innerHTML = ""; 
        const maxCapacity = 5000; 
        let totalIntensityPct = Math.min((totalPaintedPixels / maxCapacity) * 100, 100);
        barContainer.style.width = totalIntensityPct + "%";

        let leaderName = "NEUTRAL", leaderColor = "#cbd5e1", maxCount = 0;
        let gradientParts = [], currentDeg = 0;
        const legendContainer = document.getElementById("pieLegend");
        legendContainer.innerHTML = "";
        
        let activeEmotions = [];
        let negativeScore = 0;

        if (totalPaintedPixels > 0) {
            emotions.forEach(emo => {
                const count = emotionCounts[emo.name];
                if (count > maxCount) { 
                    maxCount = count; leaderName = emo.name; leaderColor = emo.hex; 
                }
                if (count > 0) {
                    const pct = (count / totalPaintedPixels) * 100;
                    const segment = document.createElement("div");
                    segment.className = "bar-segment"; segment.style.backgroundColor = emo.hex;
                    segment.style.width = pct + "%"; barContainer.appendChild(segment);

                    const startPct = currentDeg; const endPct = currentDeg + pct;
                    gradientParts.push(`${emo.hex} ${startPct}% ${endPct}%`);
                    currentDeg += pct;

                    const item = document.createElement("div");
                    item.className = "legend-item";
                    item.innerHTML = `<div><span class="legend-color" style="background:${emo.hex}"></span>${emo.name}</div><span>${Math.round(pct)}%</span>`;
                    legendContainer.appendChild(item);
                    
                    activeEmotions.push({ name: emo.name, pct: pct, type: emo.type });
                    if (["Sadness", "Fear", "Numbness", "Anger"].includes(emo.name)) {
                        negativeScore += pct;
                    }
                }
            });
            document.getElementById("visualPie").style.background = `conic-gradient(${gradientParts.join(", ")})`;
        } else {
            document.getElementById("visualPie").style.background = `conic-gradient(#334155 0% 100%)`;
            legendContainer.innerHTML = '<div style="font-style:italic; color:#64748b; font-size:0.65rem;">Paint to see breakdown...</div>';
        }

        const dominanceRatio = maxCount / totalPaintedPixels;
        let balanced = false;
        if (totalPaintedPixels > 50 && dominanceRatio < 0.40) {
            leaderName = "BALANCED"; leaderColor = "#cbd5e1"; balanced = true;
        } else if (totalPaintedPixels <= 20) {
            leaderName = "NEUTRAL"; leaderColor = "#cbd5e1";
        }

        document.getElementById("leadingEmotion").innerText = leaderName;
        document.getElementById("leadingEmotion").style.color = leaderColor;
        document.getElementById("intensityLabel").innerText = `Intensity: ${Math.round(totalIntensityPct)}%`;

        generateSummary(activeEmotions, totalIntensityPct, balanced, negativeScore, leaderName);
      }

      function generateSummary(activeEmotions, intensity, isBalanced, negativeScore, leader) {
        const aiText = document.getElementById("aiText");
        const hotlineBox = document.getElementById("hotlineBox");
        activeEmotions.sort((a,b) => b.pct - a.pct);
        let text = "";
        
        if (intensity < 5) {
            text = "The mask is currently blank. Begin painting to analyze your emotional state.";
            hotlineBox.style.display = "none";
        } else if (isBalanced) {
            text = "Your emotions appear harmonious. No single feeling is dominating, suggesting a state of complexity or emotional regulation.";
            hotlineBox.style.display = "none";
        } else {
            const top = activeEmotions[0];
            const secondary = activeEmotions.length > 1 ? activeEmotions[1] : null;
            if (top.name === "Joy" || top.name === "Passion" || top.name === "Growth") {
                text = `You are primarily radiating ${top.name}. `;
                if (secondary && secondary.type === "negative") {
                    text += `However, there is an underlying current of ${secondary.name} that may be complicating your positivity.`;
                } else {
                    text += "This indicates a generally positive or constructive mindset right now.";
                }
                hotlineBox.style.display = "none";
            } else if (top.name === "Numbness") {
                text = "A strong sense of detachment or numbness is detected. This is often a defense mechanism against overwhelming stress.";
            } else if (top.name === "Anger") {
                text = "Frustration or anger is the dominant energy. You may be feeling blocked, unheard, or reacting to a perceived injustice.";
            } else if (top.name === "Fear") {
                text = "Anxiety or fear is leading. You might be facing uncertainty or feeling unsafe in your current environment.";
            } else if (top.name === "Sadness") {
                text = "There is a significant presence of sadness or grief. You may be processing a loss or carrying a heavy emotional weight.";
            } else {
                text = `Your dominant emotion is ${top.name}.`;
            }

            if (negativeScore > 60 && intensity > 30) {
                hotlineBox.style.display = "block";
                text += " <br><br><span style='color:#f87171'><b>Note:</b> The intensity of distress signals is high. It is okay to ask for help.</span>";
            } else {
                hotlineBox.style.display = "none";
            }
        }
        aiText.innerHTML = text;
      }

      function resetFace(keepPaint = false) {
        if (!keepPaint) pCtx.clearRect(0, 0, 512, 640);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.globalCompositeOperation = "source-over"; ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath(); ctx.ellipse(100, 280, 55, 35, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(412, 280, 55, 35, 0, 0, Math.PI * 2); ctx.fill();

        ctx.lineWidth = 15; ctx.lineCap = "round";
        if (currentExpression === "neutral") {
          ctx.beginPath(); ctx.ellipse(256, 480, 60, 5, 0, 0, Math.PI * 2); ctx.fill();
        } else if (currentExpression === "happy") {
          ctx.beginPath(); ctx.arc(256, 450, 60, 0.1 * Math.PI, 0.9 * Math.PI, false); ctx.stroke();
        } else if (currentExpression === "sad") {
          ctx.beginPath(); ctx.arc(256, 530, 60, 1.1 * Math.PI, 1.9 * Math.PI, false); ctx.stroke();
        }

        ctx.globalCompositeOperation = "source-atop"; ctx.drawImage(paintLayer, 0, 0);
        if (!keepPaint) analyzeMask();
        if (mat) { 
            mat.map.needsUpdate = true; 
            mat.alphaMap.needsUpdate = true; 
            mat.emissiveMap.needsUpdate = true;
        }
      }

      // --- THREE JS ---
      let scene, camera, renderer, mat;
      function init3D() {
        const container = document.getElementById("viewer");
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 9.5);
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        
        // 1. CRITICAL: Use sRGB Encoding to prevent color darkening
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        // 2. CRITICAL: Disable Tone Mapping to show "Raw" color
        renderer.toneMapping = THREE.NoToneMapping; 

        container.appendChild(renderer.domElement);
        new THREE.OrbitControls(camera, renderer.domElement);
        scene.add(camera); // Add camera to scene so light can follow it

        const geo = new THREE.SphereGeometry(2.8, 128, 128, 0, Math.PI);
        const pos = geo.attributes.position;
        const uv = geo.attributes.uv;
        for (let i = 0; i < pos.count; i++) {
          let x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
          pos.setX(i, x * 1.05); pos.setY(i, y * 1.4);  
          uv.setXY(i, x / 2.8 + 0.5, y / 3.6 + 0.5);
          let nose = Math.exp(-(x * x * 25 + Math.pow(y - 0.1, 2) * 12));
          z += nose * 0.45; pos.setZ(i, z);
        }
        geo.computeVertexNormals();

        const canvasTex = new THREE.CanvasTexture(canvas);
        canvasTex.encoding = THREE.sRGBEncoding;

        // 3. Switch to Standard Material with High Emissive
        mat = new THREE.MeshStandardMaterial({
          map: canvasTex, 
          alphaMap: canvasTex, 
          transparent: true, 
          alphaTest: 0.05,
          side: THREE.DoubleSide, 
          roughness: 0.5,
          metalness: 0.0,
          // 4. CRITICAL: Emissive Intensity > 0.8 makes it glow, fighting all shadow
          emissive: 0xffffff,
          emissiveMap: canvasTex,
          emissiveIntensity: 0.85 
        });

        scene.add(new THREE.Mesh(geo, mat));
        
        // 5. CRITICAL: Attach light to CAMERA so face is always lit from front
        const camLight = new THREE.DirectionalLight(0xffffff, 0.5);
        camera.add(camLight);
        
        // Fill Light
        scene.add(new THREE.AmbientLight(0xffffff, 1.0)); 

        resetFace(); animate();
      }

      function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
      init3D();
    </script>
  </body>
</html>